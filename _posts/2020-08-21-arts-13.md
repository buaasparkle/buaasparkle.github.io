---
layout: post
title:  "ARTS-æ‰“å¡-13"
date:   2020-08-21 22:17:05 +0800
categories: ARTS
tags: ARTS
---

# Algorithm

***[1008. Construct Binary Search Tree from Preorder Traversal]***

éš¾åº¦ `Medium`ï¼ŒéšæœºæŒ‘é€‰

### é¢˜ç›®ä¿¡æ¯
Return the root node of a binary search tree that matches the given preorder traversal.

(Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value < node.val, and any descendant of node.right has a value > node.val.  Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)

It's guaranteed that for the given test cases there is always possible to find a binary search tree with the given requirements.

Example 1:

Input: [8,5,1,7,10,12]
Output: [8,5,10,1,7,null,12]

![leetcode_1008_example](/assets/images/arts/leetcode_1008.png)

Constraints:

1 <= preorder.length <= 100
1 <= preorder[i] <= 10^8
The values of preorder are distinct.

### æ€è·¯

å€ŸåŠ©ä¸€ä¸ªæ ˆæ¥å®ç°

1. å½“ cur ä¸º null æ—¶ cur = nodeï¼Œcur è¿›æ ˆ
2. cur å’Œ stack top æ¯”ï¼Œå¦‚æœ < topï¼Œtop.left = cur, cur è¿›æ ˆ
3. cur å’Œ stack top æ¯”ï¼Œå¦‚æœ >= topï¼Œtop å‡ºæ ˆï¼Œparent = stack.pop ç›´åˆ° stack ä¸ºç©ºï¼Œæˆ–è€… < topï¼Œparent.right = cur

### ä»£ç æäº¤

```kotlin
fun bstFromPreorder(preorder: IntArray): TreeNode? {
    val stack = Stack<TreeNode>()
    var cur: TreeNode? = null
    var root: TreeNode? = null

    for (value in preorder) {
        cur = TreeNode(value)
        if (stack.isEmpty()) {
            stack.push(cur)
            if (root == null) {
                root = cur
            }
        } else {
            var parent = stack.peek()
            if (value < parent.`val`) {
                parent.left = cur
            } else {
                while (!stack.empty() && value >= stack.peek().`val`) {
                    parent = stack.pop()
                }
                parent?.right = cur
            }
            stack.push(cur)
        }
    }
    return root
}
```

# Review

***[understanding v8â€™s bytecode]***

åº”è¯¥æ˜¯ä¸ŠæœŸæœ Android è™šæ‹Ÿæœºæ—¶æ‰¹é‡æ‰“å¼€çš„é¡µé¢ï¼Œä¹Ÿæ²¡æ³¨æ„ï¼Œæ•´ç† Tab æ—¶çœ‹åˆ°å‡†å¤‡å…³æ‰ï¼ŒçŠ¹è±«äº†ä¸€ä¸‹è¿˜æ˜¯å­¦ä¹ ä¸€ä¸‹ã€‚

ç¼–è¯‘å™¨çš„åŸºæœ¬æµç¨‹éƒ½æ˜¯ç±»ä¼¼çš„ï¼Œè§£é‡Šå‹çš„éƒ½ä¼šç»è¿‡ `è¯æ³•åˆ†æ -> è¯­æ³•åˆ†æ -> ä¸­é—´ä»£ç ` çš„è¿‡ç¨‹ï¼Œæˆªäº†å¼ æ–‡ç« çš„å›¾è¿‡æ¥ã€‚

![v8_compile_process](/assets/images/arts/v8_compile_process.png)

**éƒ¨ä»¶è¯´æ˜**

> **Ignition**, the interpreter, generates bytecode from this syntax tree. 

> **TurboFan**, the optimizing compiler, eventually takes the bytecode and generates optimized machine code from it.

V8 ç¼–è¯‘ç”Ÿæˆçš„ä¸­é—´ä»£ç ä¹Ÿå« Bytecodeï¼Œä¸ºäº†æ›´æ¥è¿‘ CPU çš„è®¡ç®—æ¨¡å‹ï¼Œä¸­é—´ä»£ç é€šå¸¸è®¾è®¡ä¸ºåŸºäºæ ˆæˆ–è€…å¯„å­˜å™¨çš„ï¼ŒJVM å°±æ˜¯åŸºäº `æ ˆ` çš„ï¼ŒIgnition æ˜¯åŸºäº `å¯„å­˜å™¨` çš„ï¼Œå®ƒä½¿ç”¨ å¯„å­˜å™¨ r0, r1, r2, ... å’Œä¸€ä¸ªç´¯åŠ å¯„å­˜å™¨ã€‚

**å­—èŠ‚ç è¯´æ˜**

> Many of the bytecodes begin with Lda or Sta. The **a** in Ld**a** and St**a** stands for **a**ccumulator. 

For example, LdaSmi [42] loads the Small Integer (Smi) 42 into the accumulator register. Star r0 stores the value currently in the accumulator in register r0.

è¿™ä¸ªç´¯åŠ å¯„å­˜å™¨ç±»ä¼¼äºåŸºäºæ ˆçš„`æ ˆé¡¶ï¼ˆæ¬¡é¡¶ï¼‰`å…ƒç´ ï¼Œæ¯”å¦‚ `Add r1` å°±æ˜¯ç›´æ¥æŠŠå¯„å­˜å™¨ 1 ä¸­çš„å€¼åŠ åˆ°ç´¯åŠ å¯„å­˜å™¨ä¸­ï¼Œå¯ä»¥å¦å­—èŠ‚ç æ›´çŸ­ä¹Ÿè§£çº¦å†…å­˜ã€‚

æœ€åæ–‡ç« æ‰‹æŠŠæ‰‹å¸¦çœ‹äº†ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œæˆ‘è¿™é‡Œå°±ä¸èµ˜è¿°è¿‡ç¨‹äº†ï¼Œå°è¯•è¿è¡Œä¸€ä¸‹å®é™…ç”Ÿæˆäº†å¾ˆå¤šå­—èŠ‚ç ï¼Œæ‰¾åˆ° incrementX ç›¸å…³éƒ¨åˆ†ï¼Œæ‘˜å½•å¦‚ä¸‹ï¼š

```
[generated bytecode for function: incrementX (0x2865c68332b1 <SharedFunctionInfo incrementX>)]
Parameter count 2
Register count 1
Frame size 8
   28 S> 0x2865c6833d96 @    0 : 0c 01             LdaSmi [1]
         0x2865c6833d98 @    2 : 26 fb             Star r0
   43 E> 0x2865c6833d9a @    4 : 28 02 00 01       LdaNamedProperty a0, [0], [1]
   37 E> 0x2865c6833d9e @    8 : 34 fb 00          Add r0, [0]
   45 S> 0x2865c6833da1 @   11 : aa                Return 
Constant pool (size = 1)
Handler Table (size = 0)
Source Position Table (size = 10)
```

ç»“æœå’Œæ–‡ä¸­ç»™å‡ºçš„åŸºæœ¬æ˜¯ä¸€è‡´çš„ï¼Œä¸è¿‡ç¼ºå¤±äº†å¸¸é‡æ± ä¸­çš„ç»†èŠ‚ã€‚

***[Dynamic screens using server-driven UI in Android]***

é€šè¿‡æœåŠ¡ç«¯ä¸‹å‘çš„ JSON ç»“æ„çš„ UI å¸ƒå±€ï¼Œå®¢æˆ·ç«¯å®ŒæˆåŠ¨æ€ UI çš„ç»˜åˆ¶ã€‚

ä¸¤ç§ View çš„æ ·å¼å®šä¹‰ï¼š
1. View Typesï¼šå®šä¹‰ View çš„æ ·å¼ï¼ŒåŸºäºå®¢æˆ·ç«¯å·²æœ‰å®ç°
2. Viewï¼šå®Œæ•´ View æè¿°ï¼Œåœ¨å®¢æˆ·ç«¯æœªæœ‰é¢„å®šä¹‰çš„æƒ…å†µä¸‹ä¹Ÿèƒ½æ ¹æ® View çš„å‚æ•°å®ç°ç»˜åˆ¶

å‡ ä¸ªå¤§ğŸ‚å…¬å¸æå‡ºæ¥çš„åº“ï¼š

- [Epoxy](https://github.com/airbnb/epoxy) from Airbnb
- [Litho](https://fblitho.com/) from Facebook
- [Proteus](https://github.com/flipkart-incubator/proteus) from Flipkart
- [Graywater](https://github.com/tumblr/Graywater) from Tumblr
- [Groupie](https://github.com/lisawray/groupie)

æœ¬æ–‡ä¸»è¦æ˜¯æ¦‚è¿°ï¼ŒğŸ‚åº“çš„å­¦ä¹ åé¢å†å®‰æ’ä¸Šã€‚

# Tips

***Android dependencies***
```shell
# ç”Ÿæˆæ ‘å‹ä¾èµ–å…³ç³»ï¼Œå¯ä»¥åŠ  --configuration
./gradlew app:dependencies

# Android ç›¸å…³ä¾èµ–ï¼Œæ˜¯æ‰“å¹³çš„ï¼Œä¸è¿‡æ²¡æœ‰å…¶ä»–é…ç½®é€‰é¡¹
./gradlew app:androidDependencies

# æŸ¥çœ‹æŸä¸€ä¸ªå…·ä½“ä¾èµ–çš„æƒ…å†µï¼ŒdebugCompileClasspath æ˜¯é…ç½®é¡¹ï¼Œå¯ä»¥æ›¿æ¢ä¸ºå…¶ä»–çš„
./gradle app:dependencyInsight --configuration debugCompileClasspath --dependency yourDep
```

***Grep OR***
grep å‘½ä»¤å– `æˆ–` çš„å…³ç³»ï¼Œéœ€è¦åŠ  \ è½¬ä¹‰ï¼Œæ¯”å¦‚ï¼š
```shell
# æ‰¾å‡ºä»¥ . å¼€å¤´æˆ–è€… @aar ç»“å°¾çš„éƒ¨åˆ†
grep '^.\|@aar$'
```

# Share
æ— 

<!-- refs -->
[1008. Construct Binary Search Tree from Preorder Traversal]: https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/

[understanding v8â€™s bytecode]: https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775

[Dynamic screens using server-driven UI in Android]: https://proandroiddev.com/dynamic-screens-using-server-driven-ui-in-android-262f1e7875c1