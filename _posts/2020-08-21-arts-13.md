---
layout: post
title:  "ARTS-打卡-13"
date:   2020-08-21 22:17:05 +0800
categories: ARTS
tags: ARTS
---

# Algorithm

***[1008. Construct Binary Search Tree from Preorder Traversal]***

难度 `Medium`，随机挑选

### 题目信息
Return the root node of a binary search tree that matches the given preorder traversal.

(Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value < node.val, and any descendant of node.right has a value > node.val.  Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)

It's guaranteed that for the given test cases there is always possible to find a binary search tree with the given requirements.

Example 1:

Input: [8,5,1,7,10,12]
Output: [8,5,10,1,7,null,12]

![leetcode_1008_example](/assets/images/arts/leetcode_1008.png)

Constraints:

1 <= preorder.length <= 100
1 <= preorder[i] <= 10^8
The values of preorder are distinct.

### 思路

借助一个栈来实现

1. 当 cur 为 null 时 cur = node，cur 进栈
2. cur 和 stack top 比，如果 < top，top.left = cur, cur 进栈
3. cur 和 stack top 比，如果 >= top，top 出栈，parent = stack.pop 直到 stack 为空，或者 < top，parent.right = cur

### 代码提交

```kotlin
fun bstFromPreorder(preorder: IntArray): TreeNode? {
    val stack = Stack<TreeNode>()
    var cur: TreeNode? = null
    var root: TreeNode? = null

    for (value in preorder) {
        cur = TreeNode(value)
        if (stack.isEmpty()) {
            stack.push(cur)
            if (root == null) {
                root = cur
            }
        } else {
            var parent = stack.peek()
            if (value < parent.`val`) {
                parent.left = cur
            } else {
                while (!stack.empty() && value >= stack.peek().`val`) {
                    parent = stack.pop()
                }
                parent?.right = cur
            }
            stack.push(cur)
        }
    }
    return root
}
```

# Review

***[understanding v8’s bytecode]***

应该是上期搜 Android 虚拟机时批量打开的页面，也没注意，整理 Tab 时看到准备关掉，犹豫了一下还是学习一下。

编译器的基本流程都是类似的，解释型的都会经过 `词法分析 -> 语法分析 -> 中间代码` 的过程，截了张文章的图过来。

![v8_compile_process](/assets/images/arts/v8_compile_process.png)

**部件说明**

> **Ignition**, the interpreter, generates bytecode from this syntax tree. 

> **TurboFan**, the optimizing compiler, eventually takes the bytecode and generates optimized machine code from it.

V8 编译生成的中间代码也叫 Bytecode，为了更接近 CPU 的计算模型，中间代码通常设计为基于栈或者寄存器的，JVM 就是基于 `栈` 的，Ignition 是基于 `寄存器` 的，它使用 寄存器 r0, r1, r2, ... 和一个累加寄存器。

**字节码说明**

> Many of the bytecodes begin with Lda or Sta. The **a** in Ld**a** and St**a** stands for **a**ccumulator. 

For example, LdaSmi [42] loads the Small Integer (Smi) 42 into the accumulator register. Star r0 stores the value currently in the accumulator in register r0.

这个累加寄存器类似于基于栈的`栈顶（次顶）`元素，比如 `Add r1` 就是直接把寄存器 1 中的值加到累加寄存器中，可以另字节码更短也解约内存。

最后文章手把手带看了一个简单的例子，我这里就不赘述过程了，尝试运行一下实际生成了很多字节码，找到 incrementX 相关部分，摘录如下：

```
[generated bytecode for function: incrementX (0x2865c68332b1 <SharedFunctionInfo incrementX>)]
Parameter count 2
Register count 1
Frame size 8
   28 S> 0x2865c6833d96 @    0 : 0c 01             LdaSmi [1]
         0x2865c6833d98 @    2 : 26 fb             Star r0
   43 E> 0x2865c6833d9a @    4 : 28 02 00 01       LdaNamedProperty a0, [0], [1]
   37 E> 0x2865c6833d9e @    8 : 34 fb 00          Add r0, [0]
   45 S> 0x2865c6833da1 @   11 : aa                Return 
Constant pool (size = 1)
Handler Table (size = 0)
Source Position Table (size = 10)
```

结果和文中给出的基本是一致的，不过缺失了常量池中的细节。

***[Dynamic screens using server-driven UI in Android]***

通过服务端下发的 JSON 结构的 UI 布局，客户端完成动态 UI 的绘制。

两种 View 的样式定义：
1. View Types：定义 View 的样式，基于客户端已有实现
2. View：完整 View 描述，在客户端未有预定义的情况下也能根据 View 的参数实现绘制

几个大🐂公司搞出来的库：

- [Epoxy](https://github.com/airbnb/epoxy) from Airbnb
- [Litho](https://fblitho.com/) from Facebook
- [Proteus](https://github.com/flipkart-incubator/proteus) from Flipkart
- [Graywater](https://github.com/tumblr/Graywater) from Tumblr
- [Groupie](https://github.com/lisawray/groupie)

本文主要是概述，🐂库的学习后面再安排上。

# Tips

***Android dependencies***
```shell
# 生成树型依赖关系，可以加 --configuration
./gradlew app:dependencies

# Android 相关依赖，是打平的，不过没有其他配置选项
./gradlew app:androidDependencies

# 查看某一个具体依赖的情况，debugCompileClasspath 是配置项，可以替换为其他的
./gradle app:dependencyInsight --configuration debugCompileClasspath --dependency yourDep
```

***Grep OR***
grep 命令取 `或` 的关系，需要加 \ 转义，比如：
```shell
# 找出以 . 开头或者 @aar 结尾的部分
grep '^.\|@aar$'
```

# Share
无

<!-- refs -->
[1008. Construct Binary Search Tree from Preorder Traversal]: https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/

[understanding v8’s bytecode]: https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775

[Dynamic screens using server-driven UI in Android]: https://proandroiddev.com/dynamic-screens-using-server-driven-ui-in-android-262f1e7875c1